name: Release

on:
  workflow_dispatch:
    inputs:
      run:
        description: 'The Package workflow run to release'
        required: true
      dry-run:
        description: 'If true, the workflow only indicates which artifacts would be uploaded'
        required: true
        type: boolean
        default: 'true'
  workflow_call:
    inputs:
      dispatch:
        description: "Marker to indicate that the workflow was dispatched via workflow_call"
        type: string
        required: false
        default: "workflow_call"

concurrency: gateway-release

jobs:
  preflight:
    name: Preflight
    runs-on: ubuntu-18.04
    outputs:
      run: ${{ steps.get-run.outputs.run }}
      version: ${{ steps.get-version.outputs.version }}
      skip-publishing: ${{ steps.check-release.outputs.skip-publishing }}
      dl-strategy: ${{ steps.get-dl-strategy.outputs.dl-strategy }}

    steps:
      ## workflow_dispatch: CI run artifacts are downloaded using `gh` (specifying the CI workflow run_id)
      ## workflow_call:     CI run artifacts are downloaded using actions/download-artifact (using the current run_id)
      - name: Get download strategy
        id: get-dl-strategy
        shell: pwsh
        run: |
          if ('${{ inputs.dispatch }}') {
            echo '::set-output name=dl-strategy::action'
          } else {
            echo '::set-output name=dl-strategy::cli'
          }

      ## workflow_dispatch: The run_id is read from the inputs
      ## workflow_call:     The run_id is the current run_id
      - name: Get run
        id: get-run
        shell: pwsh
        run: |
          if ('${{ github.event.inputs.run }}') {
            echo '::set-output name=run::${{ github.event.inputs.run }}'
          } else {
            echo '::set-output name=run::${{ github.run_id }}'
          }

      - name: Download version (action)
        if: steps.get-dl-strategy.outputs.dl-strategy == 'action'
        uses: actions/download-artifact@v3
        with:
          name: version

      - name: Download version (cli)
        if: steps.get-dl-strategy.outputs.dl-strategy == 'cli'
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.DEVOLUTIONSBOT_TOKEN }}    
        run: gh run download ${{ steps.get-run.outputs.run }} -n version --repo $Env:GITHUB_REPOSITORY

      - name: Get version
        id: get-version
        shell: pwsh
        run: |
          $Version = Get-Content VERSION -TotalCount 1
          echo "::set-output name=version::$Version"
          echo "::notice::Releasing artifacts for version $Version from run ${{ steps.get-run.outputs.run }}"

      ## If we already released this version to GitHub, publishing will be skipped
      - name: Check GitHub releases
        id: check-release
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.DEVOLUTIONSBOT_TOKEN }}
        run: |
          $Output = (gh release list --repo $Env:GITHUB_REPOSITORY) | Out-String
          $Releases = ( $Output -split '\r?\n' ).Trim()
          $Versions = ForEach($Release in $Releases) {
              $Version = ( $Release -Split '\s+' ).Trim()
              $Version = $Version.TrimStart("v")
              $Version[0]
          }

          $SkipPublishing = 'false'
          if ($Versions -Contains "${{ steps.get-version.outputs.version }}") {
            echo "::warning::GitHub already has a release version ${{ steps.get-version.outputs.version }}; publishing will be skipped"
            $SkipPublishing = 'true'
          }
          echo "::set-output name=skip-publishing::$SkipPublishing"

  containers:
    name: Containers [${{ matrix.os }} ${{ matrix.base-image }}]
    runs-on: ${{ matrix.runner }}
    environment: build-and-publish
    needs: [preflight]
    if: needs.preflight.outputs.skip-publishing == 'false' || github.event.inputs.dry-run == 'true'
    strategy:
      matrix:
        arch: [ x86_64 ]
        os: [ windows, linux ]
        base-image: [buster, servercore-ltsc2019, nanoserver-1809 ]

        include:
          - os: windows
            runner: windows-2019
          - os: linux
            runner: ubuntu-18.04
        exclude:
          - os: windows
            base-image: buster
          - os: linux
            base-image: servercore-ltsc2019
          - os: linux
            base-image: nanoserver-1809

    steps:
      - name: Download artifacts (action)
        if: needs.preflight.outputs.dl-strategy == 'action'
        uses: actions/download-artifact@v3
        with:
          name: docker
          path: docker

      - name: Download artifacts (action)
        if: needs.preflight.outputs.dl-strategy == 'action'
        uses: actions/download-artifact@v3
        with:
          name: devolutions-gateway
          path: devolutions-gateway

      - name: Download artifacts (cli)
        if: needs.preflight.outputs.dl-strategy == 'cli'
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.DEVOLUTIONSBOT_TOKEN }}
        run: gh run download ${{ needs.preflight.outputs.run }} -n docker -n devolutions-gateway --repo $Env:GITHUB_REPOSITORY

      ## workflow_call: The same artifacts persist across the entire run, so the PowerShell/DevolutionsGateway directory will still exist from the CI workflow
      - name: Manage artifacts
        shell: pwsh
        run: Remove-Item (Join-Path devolutions-gateway PowerShell DevolutionsGateway) -Recurse -ErrorAction Ignore

      - name: Prepare artifacts
        id: prepare-artifacts
        shell: pwsh
        run: |
          $PkgDir = Join-Path docker $Env:RUNNER_OS # RUNNER_OS is camelcase
          echo "::set-output name=package-path::$PkgDir"

          $SourceFileName = "DevolutionsGateway_$($Env:RUNNER_OS)_${{ needs.preflight.outputs.version }}_${{ matrix.arch }}"

          if ($Env:RUNNER_OS -eq "Windows") {
            $SourceFileName = "$($SourceFileName).exe"
            $TargetFileName = "DevolutionsGateway.exe"
          } else {
            $TargetFileName = "devolutions-gateway"
          }

          $SourcePath = Get-ChildItem -Recurse -Filter $SourceFileName -File -Path devolutions-gateway
          $TargetPath = Join-Path $PkgDir $TargetFileName
          Copy-Item $SourcePath $TargetPath

          if ($Env:RUNNER_OS -eq "Linux") {
            Invoke-Expression "chmod +x $TargetPath"
          }

      - name: Build container
        id: build-container
        shell: pwsh
        working-directory: ${{ steps.prepare-artifacts.outputs.package-path }}
        run: |
          $ImageName = "devolutions/devolutions-gateway:${{ needs.preflight.outputs.version }}-${{ matrix.base-image }}"
          if ("${{ matrix.base-image }}" -Eq "nanoserver-1809") {
            docker build --build-arg FROM_IMAGE=mcr.microsoft.com/windows/nanoserver:1809 -t "$ImageName" .
          } else {
            docker build -t "$ImageName" .
          }
          echo "::set-output name=image-name::$ImageName"
          Get-ChildItem -Recurse

      - name: Push container
        shell: pwsh
        working-directory: ${{ steps.prepare-artifacts.outputs.package-path }}
        run: |
          echo ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }} | docker login -u devolutionsbot --password-stdin
          $DockerPushCmd = 'docker push ${{ steps.build-container.outputs.image-name }}'
          Write-Host $DockerPushCmd

          $DryRun = $false
          if ('${{ github.event.inputs.dry-run }}') {
            $DryRun = [System.Convert]::ToBoolean('${{ github.event.inputs.dry-run }}')
          }

          if (-Not $DryRun) {
            Invoke-Expression $DockerPushCmd
          }

  github-release:
    name: GitHub release
    runs-on: ubuntu-18.04
    environment: build-and-publish
    needs: preflight
    if: needs.preflight.outputs.skip-publishing == 'false' || github.event.inputs.dry-run == 'true'

    steps:
      - name: Configure runner
        run: cargo install parse-changelog

      - name: Download artifacts (action)
        if: needs.preflight.outputs.dl-strategy == 'action'
        uses: actions/download-artifact@v3
        with:
          name: jetsocat
          path: jetsocat

      - name: Download artifacts (action)
        if: needs.preflight.outputs.dl-strategy == 'action'
        uses: actions/download-artifact@v3
        with:
          name: devolutions-gateway
          path: devolutions-gateway

      - name: Download artifacts (action)
        if: needs.preflight.outputs.dl-strategy == 'action'
        uses: actions/download-artifact@v3
        with:
          name: changelog
          path: changelog

      - name: Download artifacts (cli)
        if: needs.preflight.outputs.dl-strategy == 'cli'
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.DEVOLUTIONSBOT_TOKEN }}
        run: gh run download ${{ needs.preflight.outputs.run }} -n jetsocat -n devolutions-gateway -n changelog --repo $Env:GITHUB_REPOSITORY

      ## workflow_call: The same artifacts persist across the entire run, so the PowerShell/DevolutionsGateway directory will still exist from the CI workflow
      - name: Manage artifacts
        shell: pwsh
        run: Remove-Item (Join-Path devolutions-gateway PowerShell DevolutionsGateway) -Recurse -ErrorAction Ignore

      - name: Create GitHub release
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.DEVOLUTIONSBOT_TOKEN }}
        run: |
          $Version = "${{ needs.preflight.outputs.version }}"
          $HashPath = 'checksums'
          $Files = Get-ChildItem -Recurse -File -Exclude 'CHANGELOG.md' | % { Get-FileHash -Algorithm SHA256 $_.FullName }
          $Files | % { "$($_.Hash)  $(Split-Path $_.Path -leaf)" } | Out-File -FilePath $HashPath -Append -Encoding ASCII

          echo "::group::checksums"
          Get-Content $HashPath
          echo "::endgroup::"

          $ChangesPath = 'changes'
          parse-changelog $(Join-Path changelog CHANGELOG.md) $Version | Out-File -Encoding UTF8NoBOM $ChangesPath

          echo "::group::changes"
          Get-Content $ChangesPath
          echo "::endgroup::"

          $GhCmd = $(@('gh', 'release', 'create', "v$Version", "--repo", $Env:GITHUB_REPOSITORY, "--notes-file", $ChangesPath, $HashPath) + $Files.Path) -Join ' '
          Write-Host $GhCmd

          $DryRun = $false
          if ('${{ github.event.inputs.dry-run }}') {
            $DryRun = [System.Convert]::ToBoolean('${{ github.event.inputs.dry-run }}')
          }

          if (-Not $DryRun) {
            Invoke-Expression $GhCmd
          }

  psgallery-release:
    name: PowerShell release
    runs-on: ubuntu-18.04
    environment: build-and-publish
    needs: preflight
    if: needs.preflight.outputs.skip-publishing == 'false' || github.event.inputs.dry-run == 'true'

    steps:
      - name: Download artifacts (action)
        if: needs.preflight.outputs.dl-strategy == 'action'
        uses: actions/download-artifact@v3
        with:
          name: devolutions-gateway

      - name: Download artifacts (cli)
        if: needs.preflight.outputs.dl-strategy == 'cli'
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.DEVOLUTIONSBOT_TOKEN }}
        run: gh run download ${{ needs.preflight.outputs.run }} -n devolutions-gateway --repo $Env:GITHUB_REPOSITORY

      ## workflow_call: The same artifacts persist across the entire run, so the PowerShell/DevolutionsGateway directory will still exist from the CI workflow
      - name: Manage artifacts
        shell: pwsh
        run: Remove-Item (Join-Path PowerShell DevolutionsGateway) -Recurse -ErrorAction Ignore

      - name: Publish PowerShell module
        shell: pwsh
        run: |
          $Archive = Get-ChildItem -Recurse -Filter "*-ps-*.zip" -File
          Expand-Archive -Path $Archive -DestinationPath 'PowerShell'

          $PublishCmd = @('Publish-Module', '-Force', '-Path', (Join-Path PowerShell DevolutionsGateway), '-NugetApiKey', '${{ secrets.PS_GALLERY_NUGET_API_KEY }}')

          $DryRun = $false
          if ('${{ github.event.inputs.dry-run }}') {
            $DryRun = [System.Convert]::ToBoolean('${{ github.event.inputs.dry-run }}')
          }

          if ($DryRun) {
            $PublishCmd += '-WhatIf'
          }
          $PublishCmd = $PublishCmd -Join ' '
          Write-Host $PublishCmd

          try {
            Invoke-Expression $PublishCmd
          }
          catch {
            if ($_.Exception.Message -ilike "*cannot be published as the current version*is already available in the repository*") {
              echo "::warning::PowerShell module not published; this version is already listed on PSGallery"
            } else {
              Write-Error $_
              exit 1
            }
          }

  onedrive:
    name: OneDrive
    runs-on: ubuntu-18.04
    needs: preflight
    if: needs.preflight.outputs.skip-publishing == 'false' || github.event.inputs.dry-run == 'true'

    steps:
      - name: Check out Devolutions/actions
        uses: actions/checkout@v3
        with:
          repository: Devolutions/actions
          ref: master
          token: ${{ secrets.DEVOLUTIONSBOT_TOKEN }}
          path: ./.github/workflows

      ## Devolutions Toolbox is required for OneDrive uploading

      - name: Install Devolutions Toolbox
        uses: ./.github/workflows/toolbox-install
        with:
          token: ${{ secrets.DEVOLUTIONSBOT_TOKEN }}

      ## Download back the artifacts produced by the other jobs

      - name: Download artifacts (action)
        if: needs.preflight.outputs.dl-strategy == 'action'
        uses: actions/download-artifact@v3
        with:
          name: devolutions-gateway

      - name: Download artifacts (cli)
        if: needs.preflight.outputs.dl-strategy == 'cli'
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.DEVOLUTIONSBOT_TOKEN }}
        run: gh run download ${{ needs.preflight.outputs.run }} -n devolutions-gateway --repo $Env:GITHUB_REPOSITORY

      - name: Prepare upload
        id: prepare
        shell: pwsh
        run: |
          $destinationFolder = "${{ runner.temp }}/artifacts"
          $version="${{ needs.preflight.outputs.version }}"

          # Note that ".0" is appended here (required by release tooling downstream)
          Write-Host "::set-output name=version::${version}.0"
          Write-Host "::set-output name=files-to-upload::${destinationFolder}"

          New-Item -Path "$destinationFolder" -ItemType "directory"
          Move-Item -Path "./windows/x86_64/DevolutionsGateway-x86_64-${version}.msi" -Destination "$destinationFolder/DevolutionsGateway-x86_64-${version}.0.msi"

      - name: Upload to OneDrive
        uses: ./.github/workflows/upload-onedrive
        with:
          client_id: ${{ secrets.ONEDRIVE_AUTOMATION_CLIENT_ID }}
          client_secret: ${{ secrets.ONEDRIVE_AUTOMATION_CLIENT_SECRET }}          
          remote: releases
          destination_path: /Gateway/${{ steps.prepare.outputs.version }}
          conflict_behavior: fail
          files: ${{ steps.prepare.outputs.files-to-upload }}

