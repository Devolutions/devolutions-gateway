name: Release

on:
  workflow_dispatch:
    inputs:
      run:
        description: The Package workflow run to release
        required: true
      dry-run:
        description: If true, the workflow only indicates which artifacts would be uploaded
        required: true
        type: boolean
        default: true
  workflow_call:
    inputs:
      dispatch:
        description: Marker to indicate that the workflow was dispatched via workflow_call
        type: string
        required: false
        default: workflow_call
      dry-run:
        description: If true, the workflow only indicates which artifacts would be uploaded
        required: true
        type: boolean
        default: true

concurrency: gateway-release

jobs:
  preflight:
    name: Preflight
    runs-on: ubuntu-latest
    outputs:
      run: ${{ steps.get-run.outputs.run }}
      version: ${{ steps.get-version.outputs.version }}
      skip-publishing: ${{ steps.check-release.outputs.skip-publishing }}

    steps:
      ## workflow_dispatch: The run_id is read from the inputs
      ## workflow_call:     The run_id is the current run_id
      - name: Get run
        id: get-run
        run: |
          if ('${{ github.event.inputs.run }}') {
            echo "run=${{ github.event.inputs.run }}" >> $Env:GITHUB_OUTPUT
          } else {
            echo "run=${{ github.run_id }}" >> $Env:GITHUB_OUTPUT
          }
        shell: pwsh

      - name: Get dry run
        id: get-dry-run
        run: |
          $DryRun = "false"
          if ('${{ inputs.dry-run }}') {
            $DryRun = "${{ inputs.dry-run }}"
          }

          if ([System.Convert]::ToBoolean($DryRun)) {
            echo "::notice::This is a dry run; publishing will be skipped"
          } else {
            echo "::warning::This is not a dry run, release will be published!"
          }
        shell: pwsh

      - name: Download version
        run: gh run download ${{ steps.get-run.outputs.run }} -n version --repo $Env:GITHUB_REPOSITORY
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Get version
        id: get-version
        run: |
          $Version = Get-Content VERSION -TotalCount 1
          echo "version=$Version" >> $Env:GITHUB_OUTPUT
          echo "::notice::Releasing artifacts for version $Version from run ${{ steps.get-run.outputs.run }}"
        shell: pwsh

      ## If we already released this version to GitHub, publishing will be skipped
      - name: Check GitHub releases
        id: check-release
        run: |
          Set-PSDebug -Trace 1

          $Output = (gh release list --repo $Env:GITHUB_REPOSITORY) | Out-String
          $Releases = ( $Output -split '\r?\n' ).Trim()
          $Versions = ForEach($Release in $Releases) {
              $Version = ( $Release -Split '\s+' ).Trim()
              $Version = $Version.TrimStart("v")
              $Version[0]
          }

          $SkipPublishing = 'false'
          if ($Versions -Contains "${{ steps.get-version.outputs.version }}") {
            echo "::warning::GitHub already has a release version ${{ steps.get-version.outputs.version }}; publishing will be skipped"
            $SkipPublishing = 'true'
          }
          echo "skip-publishing=$SkipPublishing" >> $Env:GITHUB_OUTPUT
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  container:
    name: Container [${{ matrix.os }} ${{ matrix.base-image }}]
    environment: publish-prod
    if: ${{ needs.preflight.outputs.skip-publishing == 'false' || inputs.dry-run }}
    needs: [preflight]
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        arch: [x86_64]
        os: [linux]
        base-image: [bookworm-slim]

        include:
          - os: linux
            runner: ubuntu-latest

    steps:
      - name: Download artifacts
        run: |
          gh run download ${{ needs.preflight.outputs.run }} -n webapp-client -n docker -n devolutions-gateway-signed -n native-libs --repo $Env:GITHUB_REPOSITORY
          Move-Item -Path devolutions-gateway-signed -Destination devolutions-gateway
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare artifacts
        id: prepare-artifacts
        run: |
          Set-PSDebug -Trace 1

          $PkgDir = Join-Path docker $Env:RUNNER_OS # RUNNER_OS is camelcase
          echo "package-path=$PkgDir" >> $Env:GITHUB_OUTPUT
          Write-Host "PkgDir = $PkgDir"
          Get-ChildItem -Path "$PkgDir"

          $SourceFileName = "DevolutionsGateway_$($Env:RUNNER_OS)_${{ needs.preflight.outputs.version }}_${{ matrix.arch }}"
          $TargetFileName = "devolutions-gateway"
          Write-Host "SourceFileName = $SourceFileName"
          Write-Host "TargetFileName = $TargetFileName"

          $SourcePath = Get-ChildItem -Recurse -Filter $SourceFileName -File -Path devolutions-gateway
          $TargetPath = Join-Path $PkgDir $TargetFileName
          Write-Host "SourcePath = $SourcePath"
          Write-Host "TargetPath = $TargetPath"
          Copy-Item -Path $SourcePath -Destination $TargetPath

          if ($Env:RUNNER_OS -eq "Linux") {
            Invoke-Expression "chmod +x $TargetPath"
          }

          $XmfFileName = "libxmf.so"
          $XmfSourcePath = Get-ChildItem -Recurse -Filter $XmfFileName -File -Path native-libs
          $XmfTargetPath = Join-Path $PkgDir $XmfFileName
          Write-Host "XmfSourcePath = $XmfSourcePath"
          Write-Host "XmfTargetPath = $XmfTargetPath"
          Copy-Item -Path $XmfSourcePath -Destination $XmfTargetPath

          $WebAppArchive = Get-ChildItem -Recurse -Filter "devolutions_gateway_webapp_*.tar.gz" | Select-Object -First 1
          $TargetPath = Join-Path $PkgDir "webapp" "client"
          Write-Host "WebAppArchive = $WebAppArchive"
          Write-Host "TargetPath = $TargetPath"
          New-Item -ItemType Directory -Path $TargetPath
          tar -xvzf $WebAppArchive.FullName -C $TargetPath --strip-components=1

          $PowerShellArchive = Get-ChildItem -Recurse -Filter "DevolutionsGateway-ps-*.tar" | Select-Object -First 1
          $psModuleArchiveHash = (Get-FileHash -Path "$PowerShellArchive").Hash
          Write-Host "PS module archive hash: $psModuleArchiveHash"
          tar -xvf "$PowerShellArchive" -C "$PkgDir"
        shell: pwsh

      - name: Build container
        id: build-container
        run: |
          Set-PSDebug -Trace 1

          $Version = "${{ needs.preflight.outputs.version }}"
          $ImageName = "devolutions/devolutions-gateway:$Version"
          $LatestImageName = "devolutions/devolutions-gateway:latest"

          docker build -t "$ImageName" -t "$LatestImageName" .
          echo "image-name=$ImageName" >> $Env:GITHUB_OUTPUT
          echo "latest-image-name=$LatestImageName" >> $Env:GITHUB_OUTPUT

          Get-ChildItem -Recurse
        shell: pwsh
        working-directory: ${{ steps.prepare-artifacts.outputs.package-path }}

      - name: Push container
        run: |
          Set-PSDebug -Trace 1

          echo ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }} | docker login -u devolutionsbot --password-stdin
          $DockerPushCmd = 'docker push ${{ steps.build-container.outputs.image-name }}'
          $DockerPushLatestCmd = 'docker push ${{ steps.build-container.outputs.latest-image-name }}'
          Write-Host $DockerPushCmd
          Write-Host $DockerPushLatestCmd

          $DryRun = [System.Convert]::ToBoolean('${{ inputs.dry-run }}')
          if (-Not $DryRun) {
            Invoke-Expression $DockerPushCmd
            Invoke-Expression $DockerPushLatestCmd
          }
        shell: pwsh
        working-directory: ${{ steps.prepare-artifacts.outputs.package-path }}

  github-release:
    name: GitHub release
    environment: publish-prod
    if: ${{ needs.preflight.outputs.skip-publishing == 'false' || inputs.dry-run }}
    needs: [preflight]
    runs-on: ubuntu-latest

    steps:
      - name: Configure runner
        run: cargo install parse-changelog

      - name: Download artifacts
        run: |
          gh run download ${{ needs.preflight.outputs.run }} -n jetsocat-signed -n devolutions-gateway-signed -n devolutions-agent-signed -n webapp-client -n changelog --repo $Env:GITHUB_REPOSITORY
          Move-Item -Path jetsocat-signed -Destination jetsocat
          Move-Item -Path devolutions-gateway-signed -Destination devolutions-gateway
          Move-Item -Path devolutions-agent-signed -Destination devolutions-agent
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Manage artifacts
        run: |
          # Devolutions Agent on Linux does not have any useful feature yet, so we filter out the Linux artifacts.
          Remove-Item -Path (Join-Path devolutions-agent linux) -Recurse

          # Do not upload tun2socks.exe by itself.
          Remove-Item -Path (Join-Path devolutions-agent tun2socks) -Recurse

          # For the PowerShell module, only upload the nupkg.
          Remove-Item -Path (Join-Path devolutions-gateway PowerShell DevolutionsGateway-ps-*.tar)
        shell: pwsh

      - name: Create jetsocat ZIP files for winget
        run: |
          Set-PSDebug -Trace 1

          $Version = "${{ needs.preflight.outputs.version }}"
          $ZipFolder = "jetsocat-zips"
          New-Item -ItemType Directory -Path $ZipFolder -Force

          # Define the platforms and architectures.
          $Platforms = @(
            @{ OS = "windows"; Arch = "x86_64"; Extension = ".exe" },
            @{ OS = "windows"; Arch = "arm64"; Extension = ".exe" },
            @{ OS = "linux"; Arch = "x86_64"; Extension = "" },
            @{ OS = "linux"; Arch = "arm64"; Extension = "" },
            @{ OS = "macos"; Arch = "x86_64"; Extension = "" },
            @{ OS = "macos"; Arch = "arm64"; Extension = "" }
          )

          foreach ($Platform in $Platforms) {
            $OS = $Platform.OS
            $Arch = $Platform.Arch
            $Ext = $Platform.Extension

            # Find the original binary.
            $BinaryPattern = "jetsocat_*_${Version}_${Arch}${Ext}"
            $OriginalBinary = Get-ChildItem -Recurse -Filter $BinaryPattern -File | Select-Object -First 1

            if ($OriginalBinary) {
              # Create temporary folder for this zip.
              $TempFolder = Join-Path $ZipFolder "temp-$OS-$Arch"
              New-Item -ItemType Directory -Path $TempFolder -Force

              # Copy binary with standard name.
              $TargetName = "jetsocat${Ext}"
              $TargetPath = Join-Path $TempFolder $TargetName
              Copy-Item -Path $OriginalBinary.FullName -Destination $TargetPath

              # Create ZIP file.
              $ZipName = "jetsocat-$OS-$Arch.zip"
              $ZipPath = Join-Path $ZipFolder $ZipName
              Compress-Archive -Path $TargetPath -DestinationPath $ZipPath -Force

              Write-Host "Created $ZipName"

              # Clean up temp folder.
              Remove-Item -Path $TempFolder -Recurse -Force

              # Remove the original binary to avoid uploading it.
              Remove-Item -Path $OriginalBinary.FullName
            } else {
              Write-Warning "Could not find binary for $OS $Arch"
            }
          }
        shell: pwsh

      - name: Create GitHub release
        run: |
          Set-PSDebug -Trace 1

          $Version = "${{ needs.preflight.outputs.version }}"
          $HashPath = 'checksums'
          $Files = Get-ChildItem -Recurse -File -Exclude 'CHANGELOG.md', '*.dll' | % { Get-FileHash -Algorithm SHA256 $_.FullName }
          $Files | % { "$($_.Hash)  $(Split-Path $_.Path -leaf)" } | Out-File -FilePath $HashPath -Append -Encoding ASCII

          echo "::group::checksums"
          Get-Content $HashPath
          echo "::endgroup::"

          $ChangesPath = 'changes'
          parse-changelog $(Join-Path changelog CHANGELOG.md) $Version | Out-File -Encoding UTF8NoBOM $ChangesPath

          echo "::group::changes"
          Get-Content $ChangesPath
          echo "::endgroup::"

          $GhCmd = $(@('gh', 'release', 'create', "v$Version", "--repo", $Env:GITHUB_REPOSITORY, "--notes-file", $ChangesPath, $HashPath) + $Files.Path) -Join ' '
          Write-Host $GhCmd

          $DryRun =  [System.Convert]::ToBoolean('${{ inputs.dry-run }}')
          if (-Not $DryRun) {
            Invoke-Expression $GhCmd
          }
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  psgallery-release:
    name: PowerShell release
    environment: publish-prod
    if: ${{ needs.preflight.outputs.skip-publishing == 'false' || inputs.dry-run }}
    needs: [preflight]
    runs-on: ubuntu-latest

    steps:
      - name: Download artifacts
        run: gh run download ${{ needs.preflight.outputs.run }} -n devolutions-gateway-signed --repo $Env:GITHUB_REPOSITORY
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      ## workflow_call: The same artifacts persist across the entire run, so the PowerShell/DevolutionsGateway directory will still exist from the CI workflow
      - name: Manage artifacts
        run: Remove-Item -Path (Join-Path PowerShell DevolutionsGateway) -Recurse -ErrorAction Ignore
        shell: pwsh

      - name: Install PSResourceGet
        run: |
          Install-PSResource Microsoft.PowerShell.PSResourceGet -Scope CurrentUser -TrustRepository
        shell: pwsh

      - name: Publish PowerShell module
        run: |
          $Archive = Get-ChildItem -Recurse -Filter "*-ps-*.tar" -File
          Write-Host "Archive = $Archive"

          tar -xvf "$Archive" -C './PowerShell'
          Get-ChildItem -Path "./PowerShell" -Recurse

          $PublishCmd = @('Publish-PSResource', '-Repository', 'PSGallery', '-Path', (Join-Path PowerShell DevolutionsGateway), '-ApiKey', '${{ secrets.PS_GALLERY_NUGET_API_KEY }}')

          $DryRun = [System.Convert]::ToBoolean('${{ inputs.dry-run }}')
          if ($DryRun) {
            $PublishCmd += '-WhatIf'
          }
          $PublishCmd = $PublishCmd -Join ' '
          Write-Host "PublishCmd = $PublishCmd"

          try {
            Invoke-Expression $PublishCmd
          } catch {
            if ($_.Exception.Message -ilike "*cannot be published as the current version*is already available in the repository*") {
              echo "::warning::PowerShell module not published; this version is already listed on PSGallery"
            } else {
              Write-Error $_
              exit 1
            }
          }
        shell: pwsh

  onedrive-gateway:
    name: OneDrive (Devolutions Gateway)
    environment: onedrive-upload # for OneDrive secrets
    if: ${{ needs.preflight.outputs.skip-publishing == 'false' || inputs.dry-run }}
    needs: [preflight]
    runs-on: ubuntu-latest

    steps:
      - name: Check out Devolutions/actions
        uses: actions/checkout@v4
        with:
          repository: Devolutions/actions
          ref: v1
          token: ${{ secrets.DEVOLUTIONSBOT_TOKEN }}
          path: ./.github/workflows

      ## Devolutions Toolbox is required for OneDrive uploading

      - name: Install Devolutions Toolbox
        uses: ./.github/workflows/toolbox-install
        with:
          github_token: ${{ secrets.DEVOLUTIONSBOT_TOKEN }}

      - name: Download artifacts
        run: gh run download ${{ needs.preflight.outputs.run }} -n devolutions-gateway-signed --repo $Env:GITHUB_REPOSITORY
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare upload
        id: prepare
        run: |
          Set-PSDebug -Trace 1

          $destinationFolder = "${{ runner.temp }}/artifacts"
          $version="${{ needs.preflight.outputs.version }}"
          # Note that ".0" is appended here (required by release tooling downstream)
          $versionFull="$version.0"

          echo "version=${versionFull}" >> $Env:GITHUB_OUTPUT
          echo "files-to-upload=$destinationFolder" >> $Env:GITHUB_OUTPUT

          New-Item -Path "$destinationFolder" -ItemType "directory"

          Move-Item -Path "./windows/x86_64/DevolutionsGateway-x86_64-${version}.msi" -Destination "$destinationFolder/DevolutionsGateway-x86_64-${versionFull}.msi"
          Move-Item -Path "./windows/x86_64/DevolutionsGateway_Windows_${version}_x86_64.pdb" -Destination "$destinationFolder/DevolutionsGateway-x86_64-${versionFull}.pdb"
          Move-Item -Path "./linux/x86_64/devolutions-gateway_${version}-1_amd64.deb" -Destination "$destinationFolder/devolutions-gateway_${versionFull}_amd64.deb"
          Move-Item -Path "./linux/x86_64/devolutions-gateway_${version}-1_x86_64.rpm" -Destination "$destinationFolder/devolutions-gateway_${versionFull}_x86_64.rpm"
        shell: pwsh

      - name: Upload to OneDrive
        uses: ./.github/workflows/onedrive-upload
        if: ${{ needs.preflight.outputs.skip-publishing == 'false' && !inputs.dry-run }}
        with:
          azure_client_id: ${{ secrets.ONEDRIVE_AUTOMATION_CLIENT_ID }}
          azure_client_secret: ${{ secrets.ONEDRIVE_AUTOMATION_CLIENT_SECRET }}
          conflict_behavior: fail
          destination_path: /Gateway/${{ steps.prepare.outputs.version }}
          remote: releases
          source_path: ${{ steps.prepare.outputs.files-to-upload }}

  onedrive-agent:
    name: OneDrive (Devolutions Agent)
    environment: onedrive-upload # for OneDrive secrets
    if: ${{ needs.preflight.outputs.skip-publishing == 'false' || inputs.dry-run }}
    needs: [preflight]
    runs-on: ubuntu-latest

    steps:
      - name: Check out Devolutions/actions
        uses: actions/checkout@v4
        with:
          repository: Devolutions/actions
          ref: v1
          token: ${{ secrets.DEVOLUTIONSBOT_TOKEN }}
          path: ./.github/workflows

      ## Devolutions Toolbox is required for OneDrive uploading

      - name: Install Devolutions Toolbox
        uses: ./.github/workflows/toolbox-install
        with:
          github_token: ${{ secrets.DEVOLUTIONSBOT_TOKEN }}

      - name: Download artifacts
        run: gh run download ${{ needs.preflight.outputs.run }} -n devolutions-agent-signed --repo $Env:GITHUB_REPOSITORY
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare upload
        id: prepare
        run: |
          Set-PSDebug -Trace 1

          $destinationFolder = "${{ runner.temp }}/artifacts"
          $version="${{ needs.preflight.outputs.version }}"
          # Note that ".0" is appended here (required by release tooling downstream)
          $versionFull="$version.0"

          echo "version=${versionFull}" >> $Env:GITHUB_OUTPUT
          echo "files-to-upload=$destinationFolder" >> $Env:GITHUB_OUTPUT

          New-Item -Path "$destinationFolder" -ItemType "directory"

          Move-Item -Path "./windows/x86_64/DevolutionsAgent-x86_64-${version}.msi" -Destination "$destinationFolder/DevolutionsAgent-x86_64-${versionFull}.msi"
          Move-Item -Path "./windows/x86_64/DevolutionsAgent-x86_64-${version}.symbols.zip" -Destination "$destinationFolder/DevolutionsAgent-x86_64-${versionFull}.symbols.zip"
          Move-Item -Path "./linux/x86_64/devolutions-agent_${version}-1_amd64.deb" -Destination "$destinationFolder/devolutions-agent_${versionFull}_amd64.deb"
          Move-Item -Path "./linux/x86_64/devolutions-agent_${version}-1_x86_64.rpm" -Destination "$destinationFolder/devolutions-agent_${versionFull}_x86_64.rpm"
        shell: pwsh

      - name: Upload to OneDrive
        uses: ./.github/workflows/onedrive-upload
        if: ${{ needs.preflight.outputs.skip-publishing == 'false' && !inputs.dry-run }}
        with:
          azure_client_id: ${{ secrets.ONEDRIVE_AUTOMATION_CLIENT_ID }}
          azure_client_secret: ${{ secrets.ONEDRIVE_AUTOMATION_CLIENT_SECRET }}
          conflict_behavior: fail
          destination_path: /Agent/${{ steps.prepare.outputs.version }}
          remote: releases
          source_path: ${{ steps.prepare.outputs.files-to-upload }}

  jetsocat-publish:
    name: Jetsocat NuGet publish
    environment: publish-prod
    if: ${{ needs.preflight.outputs.skip-publishing == 'false' || inputs.dry-run }}
    needs: [preflight]
    runs-on: ubuntu-latest
    permissions:
      id-token: write

    steps:
      - name: Download jetsocat-nuget artifact
        run: gh run download ${{ needs.preflight.outputs.run }} -n jetsocat-nuget --repo $Env:GITHUB_REPOSITORY
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: NuGet login (OIDC)
        uses: NuGet/login@v1
        id: nuget-login
        with:
          user: ${{ secrets.NUGET_BOT_USERNAME }}

      - name: Publish Jetsocat NuGet package
        run: |
          Set-PSDebug -Trace 1

          $Package = Get-ChildItem -Recurse -Filter "Devolutions.Jetsocat.*.nupkg" -File | Select-Object -First 1
          Write-Host "Package = $Package"

          $PushCmd = @(
            'dotnet',
            'nuget',
            'push',
            "$($Package.FullName)",
            '--api-key',
            '${{ steps.nuget-login.outputs.NUGET_API_KEY }}',
            '--source',
            'https://api.nuget.org/v3/index.json',
            '--skip-duplicate'
          )

          $PushCmd = $PushCmd -Join ' '
          Write-Host $PushCmd

          $DryRun = [System.Convert]::ToBoolean('${{ inputs.dry-run }}')
          if (-Not $DryRun) {
            try {
              Invoke-Expression $PushCmd
            } catch {
              if ($_.Exception.Message -ilike "*package already exists*" -Or $_.Exception.Message -ilike "*already has a package*") {
                echo "::warning::Jetsocat NuGet package not published; this version is already listed on NuGet.org"
              } else {
                Write-Error $_
                exit 1
              }
            }
          }
        shell: pwsh

  remove-labels:
    name: Remove release-required labels
    if: ${{ needs.preflight.outputs.skip-publishing == 'false' && !inputs.dry-run }}
    needs: [preflight, container, github-release, psgallery-release, onedrive-gateway, onedrive-agent, jetsocat-publish]
    runs-on: ubuntu-latest

    steps:
      - name: Check out ${{ github.repository }}
        uses: actions/checkout@v4

      - name: Remove labels
        run: ./ci/remove-labels.ps1 -Label 'release-required'
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ github.token }}

  upload-sbom:
    name: Upload SBOM
    environment: sbom
    if: ${{ needs.preflight.outputs.skip-publishing == 'false' && !inputs.dry-run }}
    needs: [preflight]
    runs-on: ubuntu-latest

    steps:
      - name: Check out Devolutions/actions
        uses: actions/checkout@v4
        with:
          repository: Devolutions/actions
          ref: v1
          token: ${{ secrets.DEVOLUTIONSBOT_TOKEN }}
          path: ./.github/workflows

      ## Devolutions Toolbox is required for OneDrive uploading

      - name: Install Devolutions Toolbox
        uses: ./.github/workflows/toolbox-install
        with:
          github_token: ${{ secrets.DEVOLUTIONSBOT_TOKEN }}

      - name: Download SBOM artifact
        run: gh run download ${{ needs.preflight.outputs.run }} -n sbom --repo $GITHUB_REPOSITORY
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload SBOM to OneDrive Releases
        uses: ./.github/workflows/onedrive-upload
        with:
          azure_client_id: ${{ secrets.ONEDRIVE_AUTOMATION_CLIENT_ID }}
          azure_client_secret: ${{ secrets.ONEDRIVE_AUTOMATION_CLIENT_SECRET }}
          conflict_behavior: replace
          destination_path: /Gateway/${{ needs.preflight.outputs.version }}
          remote: releases
          source_path: bom.json

      - name: Upload SBOM to Dependency-Track
        uses: ./.github/workflows/dtrack-upload-sbom
        with:
          api_key: ${{ secrets.DTRACK_AUTOMATION_API_KEY }}
          autocreate: 'true'
          bom_filename: bom.json
          project_name: devolutions-gateway
          project_version: ${{ needs.preflight.outputs.version }}
          server_hostname: 'dtrack-api.devolutions.com'
