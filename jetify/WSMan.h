#include "Jetify.h"

#ifndef JETIFY_WSMAN_H
#define JETIFY_WSMAN_H

#ifdef _WIN32
#define WSMANAPI __stdcall
#else
#define WSMANAPI 
#endif

#ifdef _WIN32
#define WSMAN_EXPORT __declspec(dllexport)
#else
#define WSMAN_EXPORT __attribute__((visibility("default")))
#endif

#define PAL_T(_x) _x

/* Error codes needed for compatibility with Windows WinRM */
#define ERROR_WSMAN_SERVICE_STREAM_DISCONNECTED 0x803381DE
#define ERROR_WSMAN_REDIRECT_REQUESTED 0x80338199

#ifndef ERROR_INSUFFICIENT_BUFFER
#define ERROR_INSUFFICIENT_BUFFER 122
#endif

#ifndef _WIN32
typedef void* HMODULE;
#endif

/* NOTE: All strings need to be UTF-16. */
typedef void * HANDLE;
//
// -----------------------------------------------------------------------------
//  Structure for a data object.  These structures are used as output and input
//  to operations.  Eg, output from a WSManReceiveShellOutput and input to a
//      WSManSendShellInput.
// -----------------------------------------------------------------------------
//

//
// -----------------------------------------------------------------------------
// data as text
// -----------------------------------------------------------------------------
//
typedef struct _WSMAN_DATA_TEXT
{
    uint32_t bufferLength;
    const WCHAR * buffer;
}WSMAN_DATA_TEXT;

//
// -----------------------------------------------------------------------------
// binary data used by API like for example WSManSendShellInput and
//  WSManReceiveShellOutput for Shell API, the data can be stream text
//  (ANSI/UNICODE), binary content or objects or partial or full XML
// -----------------------------------------------------------------------------
//
typedef struct _WSMAN_DATA_BINARY
{
    uint32_t dataLength;
    uint8_t *data;
}WSMAN_DATA_BINARY;

//
// -----------------------------------------------------------------------------
// type of the data used by the WSMAN_DATA structure
// -----------------------------------------------------------------------------
//

enum WSManDataType
{
    WSMAN_DATA_NONE                = 0,
    WSMAN_DATA_TYPE_TEXT           = 1,
    WSMAN_DATA_TYPE_BINARY         = 2,
    WSMAN_DATA_TYPE_DWORD          = 4
};
typedef enum WSManDataType WSManDataType;

//
// -----------------------------------------------------------------------------
// Structure used to pass data as XML text, binary data or uint32_t
// -----------------------------------------------------------------------------
//
typedef struct _WSMAN_DATA
{
    WSManDataType type;
    union
    {
        WSMAN_DATA_TEXT text;
        WSMAN_DATA_BINARY binaryData;
        uint32_t number;
    };
} WSMAN_DATA;

//
// -----------------------------------------------------------------------------
//  Error structure containing fault code (a Windows error code that maps to
//  a SOAP fault) and extended error information.
//  The extended error information is the soap fault description from the protocol layer
//  including the machine where the fault was reported as well as plug-in
//  specific error text.
//
//  This error structure is used by callbacks to return detailed error information.
//
//  The error structure can contain also a transport error.
// -----------------------------------------------------------------------------
//

typedef struct _WSMAN_ERROR
{
    uint32_t code;
    // extended error information
    const WCHAR* errorDetail; // extended error description from the fault;
                                 // it can be NULL, for example in out of memory conditions
    const WCHAR* language;    // language for error description (RFC 3066 language code); it can be NULL
    const WCHAR* machineName; // machine id; it can be NULL
    const WCHAR* pluginName;  // Plug-in name for errors generated by plug-ins. Otherwise NULL.
} WSMAN_ERROR;

//
// -----------------------------------------------------------------------------
// Username and password on the remote machine
// -----------------------------------------------------------------------------
//
typedef struct _WSMAN_USERNAME_PASSWORD_CREDS
{
    const WCHAR* username;
    const WCHAR* password;
} WSMAN_USERNAME_PASSWORD_CREDS;

//
// -----------------------------------------------------------------------------
// flags used by the authenticationMechanism member of WSMAN_AUTHENTICATION_CREDENTIALS structure
// -----------------------------------------------------------------------------
//
enum WSManAuthenticationFlags
{
    WSMAN_FLAG_DEFAULT_AUTHENTICATION    = 0x0,     //Use the default authentication
    WSMAN_FLAG_NO_AUTHENTICATION         = 0x1,     //Use no authentication for a remote operation
    WSMAN_FLAG_AUTH_DIGEST               = 0x2,     //Use digest authentication for a remote operation
    WSMAN_FLAG_AUTH_NEGOTIATE            = 0x4,     //Use negotiate authentication for a remote operation (may use kerberos or ntlm)
    WSMAN_FLAG_AUTH_BASIC                = 0x8,     //Use basic authentication for a remote operation
    WSMAN_FLAG_AUTH_KERBEROS             = 0x10,    //Use kerberos authentication for a remote operation
    WSMAN_FLAG_AUTH_CREDSSP              = 0x80,    //Use CredSSP authentication for a remote operation
    WSMAN_FLAG_AUTH_CLIENT_CERTIFICATE   = 0x20     //Use client certificate authentication for a remote operation
};

//
// -----------------------------------------------------------------------------
// Structure for passing the credentials and the authentication mechanism
// -----------------------------------------------------------------------------
//
typedef struct _WSMAN_AUTHENTICATION_CREDENTIALS
{
    uint32_t authenticationMechanism; // can be 0 (the user did not specify an
                                   // authentication mechanism, WSMan client
                                   // will choose between Kerberos and Negotiate only);
                                   // if it is not 0, it must be one of the
                                   // values from WSManAuthenticationFlags
                                   // enumeration
    union
    {
        WSMAN_USERNAME_PASSWORD_CREDS userAccount;
        const WCHAR* certificateThumbprint;
    };
}WSMAN_AUTHENTICATION_CREDENTIALS;

//
// -----------------------------------------------------------------------
// Options
// -----------------------------------------------------------------------
//
typedef struct _WSMAN_OPTION
{
    const WCHAR * name;
    const WCHAR * value;
    BOOL mustComply;
} WSMAN_OPTION;

typedef struct _WSMAN_OPTION_SET
{
    uint32_t optionsCount;
    WSMAN_OPTION *options;
    BOOL optionsMustUnderstand;
} WSMAN_OPTION_SET;

typedef struct _WSMAN_OPTION_SETEX
{
    uint32_t optionsCount;
    WSMAN_OPTION *options;
    BOOL optionsMustUnderstand;
    const WCHAR* *optionTypes;
} WSMAN_OPTION_SETEX;

//
// -----------------------------------------------------------------------------
//  Structures containing information for addressing the endpoint.
// -----------------------------------------------------------------------------
//
typedef struct _WSMAN_KEY
{
    const WCHAR * key;
    const WCHAR * value;
} WSMAN_KEY;

typedef struct _WSMAN_SELECTOR_SET
{
    uint32_t numberKeys; // Number of keys (selectors)
    WSMAN_KEY *keys;  // Array of key names and values
} WSMAN_SELECTOR_SET;

//
// -----------------------------------------------------------------------------
// Structure reserved for future use (Fragment Level WS-Transfer)
// -----------------------------------------------------------------------------
//
typedef struct _WSMAN_FRAGMENT
{
    const WCHAR * path;               // fragment path - WS-Transfer
    const WCHAR * dialect;        // dialect for Fragment path

} WSMAN_FRAGMENT;

//
// -----------------------------------------------------------------------------
// Structure reserved for future use (Filter Enumeration/Eventing)
// -----------------------------------------------------------------------------
//
typedef struct _WSMAN_FILTER
{
    const WCHAR * filter;              // filter enumeration/subscription - allows ad-hoc queries using quey languages like SQL
    const WCHAR * dialect;         // dialect for filter predicate

} WSMAN_FILTER;

#define WSMAN_OPERATION_INFOV1  0x00000000
#define WSMAN_OPERATION_INFOV2  0xaabbccdd

typedef struct _WSMAN_OPERATION_INFO
{
    WSMAN_FRAGMENT fragment;              // optional element to support Fragment transfer or
    WSMAN_FILTER filter;                  // optional Filter WS-Enumerate/WS-Eventing
    WSMAN_SELECTOR_SET selectorSet;
    WSMAN_OPTION_SET optionSet;
    void *reserved;
    uint32_t version;
} WSMAN_OPERATION_INFO;

typedef struct _WSMAN_OPERATION_INFOEX
{
    WSMAN_FRAGMENT fragment;              // optional element to support Fragment transfer or
    WSMAN_FILTER filter;                  // optional Filter WS-Enumerate/WS-Eventing
    WSMAN_SELECTOR_SET selectorSet;
    WSMAN_OPTION_SETEX optionSet;
    uint32_t version;
    const WCHAR* uiLocale;
    const WCHAR* dataLocale;
} WSMAN_OPERATION_INFOEX;
//
// -----------------------------------------------------------------------------
//  Client Initialization/Deinitialization functions
// -----------------------------------------------------------------------------
//

typedef struct WSMAN_API *WSMAN_API_HANDLE;

//
// -----------------------------------------------------------------------------
// This API is used to initialize the WinRM client;
// It can be used by different clients on the same process, ie svchost.exe.
// Returns a nonzero error code upon failure
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT uint32_t WSMANAPI WSManInitialize(
    uint32_t flags,
    WSMAN_API_HANDLE *apiHandle
    );

//
// -----------------------------------------------------------------------------
// This API deinitializes the Winrm client stack; all operations will
//  finish before this API will return; this is a sync call;
//  it is highly recommended that all operations are explictly cancelled
//  and all sessions are closed before calling this API
// Returns non zero error code upon failure
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT uint32_t WSMANAPI WSManDeinitialize(
    WSMAN_API_HANDLE apiHandle,
    uint32_t flags
    );

//
// -----------------------------------------------------------------------------
// This API returns a NULL terminated unicode string containing the message
//  of an error number and an optional language identifier. The optional
//  parameter languageCode specifies the UI language as RFC 3066 language code
//  that should be used to localize the message (if not specified, the thread's
//  UI language will be used). If the function cannot find a message for that
//  language, it returns ERROR_RESOURCE_LANG_NOT_FOUND. The function copies
//  the formatted message text to an output buffer.
//
// Returns non zero error code upon failure. If the output buffer is not
//  big enough or NULL, the function returns ERROR_INSUFFICIENT_BUFFER and
//  the messageLengthUsed parameter contains the requested size of the buffer.
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT uint32_t WSMANAPI WSManGetErrorMessage(
    WSMAN_API_HANDLE apiHandle,
    uint32_t flags,            // reserved for future use; must be 0
    const WCHAR* languageCode,    // the RFC 3066 language code; it can be NULL
    uint32_t errorCode,        // error code for the requested error message
    uint32_t messageLength,    // message length, including NULL terminator
    WCHAR* message,
    uint32_t* messageLengthUsed  // effective message length, including NULL terminator
    );


//
// -----------------------------------------------------------------------------
// Unsigned long integer value that contains the proxy access type
// By default, wsman uses WSMAN_OPTION_PROXY_WINHTTP_PROXY_CONFIG -
//  the proxy settings configured for WinHTTP. The WinHTTP proxy settings
//  can be set with Proxycfg.exe or by using netsh command.
// When WSMAN_OPTION_PROXY_IE_PROXY_CONFIG is specified, the current user's
//  Internet Explorer proxy settings for the current active network connection.
//  This option requires the user profile to be loaded, so the option can
//  be directly used when called within a process that is running under
//  an interactive user account identity; if the client application is running
//  under a user context different then the interactive user, the client
//  application has to explicitly load the user profile prior to using this option.
// IMPORTANT: proxy configuration is supported for HTTPS only; for HTTP, the direct
//      connection to the server is used
// -----------------------------------------------------------------------------
//
enum WSManProxyAccessType
{
    WSMAN_OPTION_PROXY_IE_PROXY_CONFIG          = 1,    // use the Internet Explorer proxy configuration for the current user
    WSMAN_OPTION_PROXY_WINHTTP_PROXY_CONFIG     = 2,    // default: proxy settings configured for WinHTTP, using the ProxyCfg.exe utility
    WSMAN_OPTION_PROXY_AUTO_DETECT              = 4,    // Force autodetection of proxy
    WSMAN_OPTION_PROXY_NO_PROXY_SERVER          = 8,    // do not use a proxy server - resolves all host names locally
};

//
// -----------------------------------------------------------------------------
// Structure used to set the proxy information per session
// -----------------------------------------------------------------------------
//

typedef struct _WSMAN_PROXY_INFO
{
    uint32_t accessType;
    WSMAN_AUTHENTICATION_CREDENTIALS authenticationCredentials; // credentials and authentication scheme used for proxy
} WSMAN_PROXY_INFO;

//
// -----------------------------------------------------------------------------
//  Client Session
// -----------------------------------------------------------------------------
//
typedef struct WSMAN_SESSION *WSMAN_SESSION_HANDLE;

//
// -----------------------------------------------------------------------------
// Creates a session which can be used to perform subsequent operations
// Returns a non zero error code upon failure
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT uint32_t WSMANAPI WSManCreateSession(
    WSMAN_API_HANDLE apiHandle,
    const WCHAR* connection,             // if NULL, then connection will default to localhost
    uint32_t flags,
    WSMAN_AUTHENTICATION_CREDENTIALS *serverAuthenticationCredentials,
    WSMAN_PROXY_INFO *proxyInfo,
    WSMAN_SESSION_HANDLE *session
    );

//
// -----------------------------------------------------------------------------
// Frees memory of session and closes all related operations before returning; this is sync call
// it is recommended that all pending operations are either completed or cancelled before calling this API
// Returns a non zero error code upon failure
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT uint32_t WSMANAPI WSManCloseSession(
    WSMAN_SESSION_HANDLE session,
    uint32_t flags
    );

//
// default operation timeout for network operations - 1 min = 60000ms
//
#define WSMAN_DEFAULT_TIMEOUT_MS 60000

//
// -----------------------------------------------------------------------------
// Extended options set for the session
// -----------------------------------------------------------------------------
//
enum WSManSessionOption
{
    //
    //Timeouts
    //

    WSMAN_OPTION_DEFAULT_OPERATION_TIMEOUTMS = 1,// uint32_t - default timeout in ms that applies to all operations on the client side

    WSMAN_OPTION_MAX_RETRY_TIME             = 11, // uint32_t (read only) - maximum time for Robust connection retries
    WSMAN_OPTION_TIMEOUTMS_CREATE_SHELL      = 12,// uint32_t - timeout in ms for WSManCreateShell operations
    WSMAN_OPTION_TIMEOUTMS_RUN_SHELL_COMMAND =13,// uint32_t - timeout in ms for WSManRunShellCommand operations
    WSMAN_OPTION_TIMEOUTMS_RECEIVE_SHELL_OUTPUT =14,// uint32_t - timeout in ms for WSManReceiveShellOutput operations
    WSMAN_OPTION_TIMEOUTMS_SEND_SHELL_INPUT  = 15,// uint32_t - timeout in ms for WSManSendShellInput operations
    WSMAN_OPTION_TIMEOUTMS_SIGNAL_SHELL      = 16,// uint32_t - timeout in ms for WSManSignalShell and WSManCloseCommand operations
    WSMAN_OPTION_TIMEOUTMS_CLOSE_SHELL       = 17,// uint32_t - timeout in ms for WSManCloseShell operations

    //
    // connection options
    //

    WSMAN_OPTION_SKIP_CA_CHECK              = 18,// uint32_t  - 1 to not validate the CA on the server certificate; 0 - default
    WSMAN_OPTION_SKIP_CN_CHECK              = 19,// uint32_t  - 1 to not validate the CN on the server certificate; 0 - default
    WSMAN_OPTION_UNENCRYPTED_MESSAGES       = 20,// uint32_t  - 1 to not encrypt the messages; 0 - default
    WSMAN_OPTION_UTF16                      = 21,// uint32_t  - 1 Send all network packets for remote operatons in UTF16; 0 - default is UTF8
    WSMAN_OPTION_ENABLE_SPN_SERVER_PORT     = 22,// uint32_t  - 1 When using negotiate, include port number in the connection SPN; 0 - default
                                                 // Used when not talking to the main OS on a machine but, for instance, a BMC
    WSMAN_OPTION_MACHINE_ID                 = 23,// uint32_t  - 1 Identify this machine to the server by including the MachineID header; 0 - default

    //
    // other options
    //
    WSMAN_OPTION_LOCALE                     = 25,// string - RFC 3066 language code
    WSMAN_OPTION_UI_LANGUAGE                = 26,// string - RFC 3066 language code
    WSMAN_OPTION_MAX_ENVELOPE_SIZE_KB       = 28,// uint32_t - max SOAP envelope size (kb) - default 150kb from winrm config
                                                // (see 'winrm help config' for more details); the client SOAP packet size cannot surpass
                                                //  this value; this value will be also sent to the server in the SOAP request as a
                                                //  MaxEnvelopeSize header; the server will use min(MaxEnvelopeSizeKb from server configuration,
                                                //  MaxEnvelopeSize value from SOAP).
    WSMAN_OPTION_SHELL_MAX_DATA_SIZE_PER_MESSAGE_KB = 29,// uint32_t (read only) - max data size (kb) provided by the client, guaranteed by
                                                     //  the winrm client implementation to fit into one SOAP packet; this is an
                                                     // approximate value calculated based on the WSMAN_OPTION_MAX_ENVELOPE_SIZE_KB (default 500kb),
                                                     // the maximum possible size of the SOAP headers and the overhead of the base64
                                                     // encoding which is specific to WSManSendShellInput API; this option can be used
                                                     // with WSManGetSessionOptionAsDword API; it cannot be used with WSManSetSessionOption API.
    WSMAN_OPTION_REDIRECT_LOCATION          = 30,// string - read-only, cannot set
    WSMAN_OPTION_SKIP_REVOCATION_CHECK  = 31,// uint32_t  - 1 to not validate the revocation status on the server certificate; 0 - default
    WSMAN_OPTION_ALLOW_NEGOTIATE_IMPLICIT_CREDENTIALS  = 32,// uint32_t  - 1 to allow default credentials for Negotiate (this is for SSL only); 0 - default
    WSMAN_OPTION_USE_SSL                    = 33,    // uint32_t - When using just a machine name in the connection string use an SSL connection. 0 means HTTP, 1 means HTTPS.  Default is 0.
    WSMAN_OPTION_USE_INTERACTIVE_TOKEN  = 34        // uint32_t - When creating connection on local machine, use interactive token feature. 1 - default
};
typedef enum WSManSessionOption WSManSessionOption;

//
// -----------------------------------------------------------------------------
// WSManSetSessionOption API - set session options
//  Returns a non zero error code upon failure
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT uint32_t WSMANAPI WSManSetSessionOption(
    WSMAN_SESSION_HANDLE session,
    WSManSessionOption option,
    WSMAN_DATA *data
    );

//
// -----------------------------------------------------------------------------
// WSManGetSessionOptionAsDword API - get a session option
//  Returns a non zero error code upon failure
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT uint32_t WSMANAPI WSManGetSessionOptionAsDword(
    WSMAN_SESSION_HANDLE session,
    WSManSessionOption option,
    uint32_t *value
    );

//
// -----------------------------------------------------------------------------
// WSManGetSessionOptionAsString API - get a session option
//  Returns a non zero error code upon failure
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT uint32_t WSMANAPI WSManGetSessionOptionAsString(
    WSMAN_SESSION_HANDLE session,
    WSManSessionOption option,
    uint32_t stringLength,
    WCHAR* string,
    uint32_t* stringLengthUsed
    );

//
// -----------------------------------------------------------------------------
// Handle returned by WS-Transfer and WS-Enumerate operations
// -----------------------------------------------------------------------------
//
typedef struct WSMAN_OPERATION *WSMAN_OPERATION_HANDLE;

//
// -----------------------------------------------------------------------------
// flags used by WSMAN_SHELL_COMPLETION_FUNCTION callback function
// -----------------------------------------------------------------------------
//
enum WSManCallbackFlags
{
    //
    // Flag that marks the end of any single step of multistep operation
    //
    WSMAN_FLAG_CALLBACK_END_OF_OPERATION     = 0x1,

    //
    // WSMAN_SHELL_COMPLETION_FUNCTION API specific flags
    //  end of a particular stream; it is used for optimization purposes if the shell
    //  knows that no more output will occur for this stream; in some conditions this
    //  cannot be determined.
    //
    WSMAN_FLAG_CALLBACK_END_OF_STREAM        = 0x8,

    // Flag that if present on CreateShell callback indicates that it supports disconnect
    WSMAN_FLAG_CALLBACK_SHELL_SUPPORTS_DISCONNECT = 0x20,

    // Flag that indicates that the shell got disconnected due to netowrk failure
    WSMAN_FLAG_CALLBACK_SHELL_AUTODISCONNECTED     = 0x40,

    // Flag indicates that the client shell detected a network failure
    WSMAN_FLAG_CALLBACK_NETWORK_FAILURE_DETECTED = 0x100,

    // Flag indicates that client shell is retrying to establish network connection with the server
    WSMAN_FLAG_CALLBACK_RETRYING_AFTER_NETWORK_FAILURE = 0x200,

    // Flag indicates that client shell successfully reconnected with the server after attempting to reconnect to the server
    WSMAN_FLAG_CALLBACK_RECONNECTED_AFTER_NETWORK_FAILURE = 0x400,

    // Flag indicates that the client shell attempts to reconnect to the server failed and hence it is AutoDisconnecting
    WSMAN_FLAG_CALLBACK_SHELL_AUTODISCONNECTING      = 0x800,

    // Flag indicates that the client shell got into broken state in the middle of retry notification sequence due to some internal error at wsman layer
    WSMAN_FLAG_CALLBACK_RETRY_ABORTED_DUE_TO_INTERNAL_ERROR = 0x1000,

    // Flag that indicates for a receive operation that a delay stream request has been processed
    WSMAN_FLAG_CALLBACK_RECEIVE_DELAY_STREAM_REQUEST_PROCESSED = 0X2000
};

//
// -----------------------------------------------------------------------------
// Closes an asynchronous operation; if the callback associated with the operation
//  is pending and have not completed when WSManCloseOperation is called, then
//  the function marks the operation for deletion and returns; If the callback was not called,
//  the operation is cancelled and the operation callback is called with
//  WSMAN_ERROR_OPERATION_ABORTED error; the operation handle is freed in all cases
//  after the callback returns.
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT uint32_t WSMANAPI WSManCloseOperation(
    WSMAN_OPERATION_HANDLE operationHandle,
    uint32_t flags
    );

//
//------------------------------------------------------------------------
// Shell Client API
//  The API set includes the ability to create a shell, execute one or
//  more commands, possibly pipe input stream to the command, collect the
//  output stream from the command, terminate the command and finally
//  close the shell. The client must retrieve the output initiating
//  a WSManReceiveShellOutput once; the underlying implementation will
//  handle pulling the data from the command, until the command is done.
//  For each received stream, the completion function will be called with
//  the status of the command.
//
//  WSManCloseCommand or WSManCloseShell can be called any time to close the
//    commmand or a shell operation. The callback will be called with
//    WSMAN_FLAG_CALLBACK_END_OF_OPERATION flag to mark the end of the operation.
//    See WSManCloseCommand/WSManCloseShell API description for more info.
// -----------------------------------------------------------------------
//

//
// -----------------------------------------------------------------------
// Shell handle returned by WSManCreateShell API
// -----------------------------------------------------------------------
//
typedef struct WSMAN_SHELL *WSMAN_SHELL_HANDLE;

//
// -----------------------------------------------------------------------
// Command handle returned by WSManRunShellCommand API
// -----------------------------------------------------------------------
//
typedef struct WSMAN_COMMAND *WSMAN_COMMAND_HANDLE;

//
// -----------------------------------------------------------------------
// predefined stream ids
// -----------------------------------------------------------------------
//
#define WSMAN_STREAM_ID_STDIN PAL_T("stdin")
#define WSMAN_STREAM_ID_STDOUT PAL_T("stdout")
#define WSMAN_STREAM_ID_STDERR PAL_T("stderr")

//
// -----------------------------------------------------------------------
// stream selector - array of stream ids; ie "stdin" or "stdout" or "stderr"
// -----------------------------------------------------------------------
//
typedef struct _WSMAN_STREAM_ID_SET
{
    uint32_t streamIDsCount;
    const WCHAR* *streamIDs;

} WSMAN_STREAM_ID_SET;

//
// -----------------------------------------------------------------------
// Environment variable
// -----------------------------------------------------------------------
//
typedef struct _WSMAN_ENVIRONMENT_VARIABLE
{
    const WCHAR* name;
    const WCHAR* value;

} WSMAN_ENVIRONMENT_VARIABLE;

//
// -----------------------------------------------------------------------
// environment variable set - array of environment variables
// -----------------------------------------------------------------------
//
typedef struct _WSMAN_ENVIRONMENT_VARIABLE_SET
{
    uint32_t varsCount;
    WSMAN_ENVIRONMENT_VARIABLE *vars;

} WSMAN_ENVIRONMENT_VARIABLE_SET;

//
// -----------------------------------------------------------------------
// Shell initialization parameters
// -----------------------------------------------------------------------
//
typedef struct _WSMAN_SHELL_STARTUP_INFO_V11
{
    WSMAN_STREAM_ID_SET *inputStreamSet;
    WSMAN_STREAM_ID_SET *outputStreamSet;
    uint32_t idleTimeoutMs;
    const WCHAR* workingDirectory;
    WSMAN_ENVIRONMENT_VARIABLE_SET *variableSet;

    const WCHAR* name;
} WSMAN_SHELL_STARTUP_INFO_V11;


typedef WSMAN_SHELL_STARTUP_INFO_V11 WSMAN_SHELL_STARTUP_INFO;

typedef struct _WSMAN_SHELL_DISCONNECT_INFO
{
    uint32_t idleTimeoutMs;
} WSMAN_SHELL_DISCONNECT_INFO;

//
// -----------------------------------------------------------------------
// Pre-defined URIs
// -----------------------------------------------------------------------
//
#define WSMAN_SHELL_NS PAL_T("http://schemas.microsoft.com/wbem/wsman/1/windows/shell")
#define WSMAN_SHELL_NS_LEN (sizeof(WSMAN_SHELL_NS)/sizeof(char)-1)

//
// -----------------------------------------------------------------------
// URI to create a Windows command shell; used with WSManCreateShell API
// -----------------------------------------------------------------------
//
#define WSMAN_CMDSHELL_URI WSMAN_SHELL_NS "/cmd"


//
// -----------------------------------------------------------------------
// Windows shell options
// -----------------------------------------------------------------------
//
enum WSManShellFlag
{
    //Turn off compression for Send/Receive operations.  By default compression is
    //turned on, but if communicating with a down-level box it may be necessary to
    //do this.  Other reasons for turning it off is due to the extra memory consumption
    //and CPU utilization that is used as a result of compression.
    WSMAN_FLAG_NO_COMPRESSION = 0x1,
    WSMAN_FLAG_DELETE_SERVER_SESSION = 0x2,
    //Enable the service to drop operation output when running disconnected
    WSMAN_FLAG_SERVER_BUFFERING_MODE_DROP = 0x4,
    //Enable the service to block operation progress when output buffers are full
    WSMAN_FLAG_SERVER_BUFFERING_MODE_BLOCK = 0x8,
    //Enable receive call to not immediately retrieve results. Only applicable for Receive calls on commands
    WSMAN_FLAG_RECEIVE_DELAY_OUTPUT_STREAM = 0X10
};
typedef enum WSManShellFlag WSManShellFlag;

//
// -----------------------------------------------------------------------
// Windows command shell specific options
// -----------------------------------------------------------------------
//

//
// -----------------------------------------------------------------------
// Code page option name to be used with WSManCreateShell
//  API to remotely set the code page
// -----------------------------------------------------------------------
//
#define WSMAN_CMDSHELL_OPTION_CODEPAGE MI("WINRS_CODEPAGE")

//
// -----------------------------------------------------------------------
// Option name used with WSManCreateShell API to not load the
//  user profile on the remote server
// -----------------------------------------------------------------------
//
#define WSMAN_SHELL_OPTION_NOPROFILE PAL_T("WINRS_NOPROFILE")

//
// -----------------------------------------------------------------------
// Option name used with WSManRunShellCommand API to
//  indicate that the client side mode of standard input is Console;
//  default  implies Pipe.
// -----------------------------------------------------------------------
//
#define WSMAN_CMDSHELL_OPTION_CONSOLEMODE_STDIN PAL_T("WINRS_CONSOLEMODE_STDIN")

//
// -----------------------------------------------------------------------
// to be used with WSManRunShellCommand API to not use cmd.exe /c prefix when launching the command
// -----------------------------------------------------------------------
//
#define WSMAN_CMDSHELL_OPTION_SKIP_CMD_SHELL PAL_T("WINRS_SKIP_CMD_SHELL")

//
// -----------------------------------------------------------------------
// pre-defined command states
// -----------------------------------------------------------------------
//
#define WSMAN_COMMAND_STATE_DONE WSMAN_SHELL_NS PAL_T("/CommandState/Done")
#define WSMAN_COMMAND_STATE_PENDING WSMAN_SHELL_NS PAL_T("/CommandState/Pending")
#define WSMAN_COMMAND_STATE_RUNNING WSMAN_SHELL_NS PAL_T("/CommandState/Running")

//
// -----------------------------------------------------------------------
// Data structure returned after a Receive operation; each WSMAN_RECEIVE_DATA_RESULT
//  has a stream element with data that can be text (ANSI/UNICODE), binary content,
//  objects, or partial or full XML. In addition, the command state is reported
//  to the client and exitCode if the command is done.
//
// This structure is allocated and owned by the winrm stack and it is valid
//  in the completion function only
// -----------------------------------------------------------------------
//
typedef struct _WSMAN_RECEIVE_DATA_RESULT
{
    const WCHAR* streamId;          // string - any output stream name from the list passed to
                              // the server when creating the shell
    WSMAN_DATA streamData;    // always data as binary; can be stream text (ANSI/UNICODE), binary content or objects or partial or full XML

    // command state string values (shell specific) - the state of the command for which status is being reported
    const WCHAR* commandState;      // if WSMAN_COMMAND_STATE_DONE then the command should be closed at this moment
    uint32_t exitCode;

} WSMAN_RECEIVE_DATA_RESULT;


typedef struct _WSMAN_CONNECT_DATA
{
    WSMAN_DATA data;
} WSMAN_CONNECT_DATA;

typedef struct _WSMAN_CREATE_SHELL_DATA
{
    WSMAN_DATA data;
} WSMAN_CREATE_SHELL_DATA;

typedef union _WSMAN_RESPONSE_DATA
{
    WSMAN_RECEIVE_DATA_RESULT receiveData;
    WSMAN_CONNECT_DATA connectData;
    WSMAN_CREATE_SHELL_DATA createData;
} WSMAN_RESPONSE_DATA;

//
// -----------------------------------------------------------------------
// Completion function used by all Shell functions
// Returns error->code != 0 upon error; use error->errorDetail structure
//  for extended error informations; the callback is called for each
//  shell operation; after a WSManReceiveShellOutput operation is initiated,
//  the callback is called for each output stream element or if error;
//  the underlying implementation handles the polling of stream data
//  from the command or shell. If WSMAN_COMMAND_STATE_DONE state is received, no more
//  streams will be received from the command, so the command can be closed
//  using WSManCloseCommand(command).
//
// If error->code != 0, the result is guaranteed to be NULL
//
// The error and result objects are allocated and owned by the winrm
//  client stack; they are valid during the callback only; the user
//  has to synchronously copy the data in the callback
//
// This callback function will use the current access token, whether it is
//  a process or impersonation token.
// -----------------------------------------------------------------------
//


typedef void (*WSMAN_SHELL_COMPLETION_FUNCTION)(
    void* operationContext,                     //user defined context
    uint32_t flags,                                         // one or more flags from WSManCallbackFlags
    WSMAN_ERROR *error,                             // error allocated and owned by the winrm stack; valid in the callback only;
    WSMAN_SHELL_HANDLE shell,                       // shell handle associated with the user context; must be closed using WSManCloseShell
    WSMAN_COMMAND_HANDLE command,               // command handle associated with the user context; must be closed using WSManCloseCommand
    WSMAN_OPERATION_HANDLE operationHandle,     // valid only for Send/Receive/Signal operations; must be closed using WSManCloseOperation
    WSMAN_RESPONSE_DATA *data                   // output data from command/shell; allocated internally and owned by the winrm stack
                                                         // valid only within this function. Currently used to send back receive stream data and
                                                         // open Xml content in rsp:ConnectResponse
    );
//
// -----------------------------------------------------------------------------
// Asynchronous structure to be passed to all Shell operations;
//  it contains an optional user context and the callback function
// -----------------------------------------------------------------------------
//
typedef struct _WSMAN_SHELL_ASYNC
{
    void* operationContext;
    WSMAN_SHELL_COMPLETION_FUNCTION completionFunction;
} WSMAN_SHELL_ASYNC;

//
// -----------------------------------------------------------------------------
//  WSManRunShellCommand API - rsp:Command
// -----------------------------------------------------------------------------
//

//
// -----------------------------------------------------------------------
// array of command arguments
// -----------------------------------------------------------------------
//
typedef struct _WSMAN_COMMAND_ARG_SET
{
    uint32_t argsCount;
    const WCHAR* *args;

} WSMAN_COMMAND_ARG_SET;

//
// -----------------------------------------------------------------------------
//  WSManSignalShell API - rsp:Signal
// -----------------------------------------------------------------------------
//

//
// -----------------------------------------------------------------------
// control codes for the command
// -----------------------------------------------------------------------
//
#define WSMAN_SIGNAL_SHELL_CODE_TERMINATE WSMAN_SHELL_NS PAL_T("/signal/terminate")
#define WSMAN_SIGNAL_SHELL_CODE_CTRL_C WSMAN_SHELL_NS PAL_T("/signal/ctrl_c")
#define WSMAN_SIGNAL_SHELL_CODE_CTRL_BREAK WSMAN_SHELL_NS PAL_T("/signal/ctrl_break")

WSMAN_EXPORT void WSMANAPI WSManSignalShell(
    WSMAN_SHELL_HANDLE shell,
    WSMAN_COMMAND_HANDLE command,         // if NULL, the Signal will be sent to the shell
    uint32_t flags,
    const WCHAR* code,             // signal code
    WSMAN_SHELL_ASYNC *async,
    WSMAN_OPERATION_HANDLE *signalOperation  // should be closed using WSManCloseOperation
);

//
// -----------------------------------------------------------------------------
//  WSManReceiveShellOutput API - rsp:Receive
// -----------------------------------------------------------------------------
//

WSMAN_EXPORT void WSMANAPI WSManReceiveShellOutput(
    WSMAN_SHELL_HANDLE shell,
    WSMAN_COMMAND_HANDLE command,
    uint32_t flags,
    WSMAN_STREAM_ID_SET *desiredStreamSet,  // request output from a particular stream or list of streams
    WSMAN_SHELL_ASYNC *async,
    WSMAN_OPERATION_HANDLE *receiveOperation // should be closed using WSManCloseOperation
);

//
// -----------------------------------------------------------------------------
//  WSManSendShellInput API - rsp:Send
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT void WSMANAPI WSManSendShellInput(
    WSMAN_SHELL_HANDLE shell,
    WSMAN_COMMAND_HANDLE command,
    uint32_t flags,
    const WCHAR* streamId,               // input stream name
    WSMAN_DATA *streamData,        // data as binary - that can contain text (ANSI/UNICODE),
                                        // binary content or objects or partial or full XML
    BOOL endOfStream,
    WSMAN_SHELL_ASYNC *async,
    WSMAN_OPERATION_HANDLE *sendOperation // should be closed using WSManCloseOperation
);

//
// -----------------------------------------------------------------------------
// WSManCloseCommand API
// -----------------------------------------------------------------------------
//

//
// -----------------------------------------------------------------------------
// Closes a command (signals the termination of a command); the WSManCloseCommand callback
//  is called with WSMAN_FLAG_CALLBACK_END_OF_OPERATION flag as result of this operation
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT void WSMANAPI WSManCloseCommand(
    WSMAN_COMMAND_HANDLE commandHandle,
    uint32_t flags,
    WSMAN_SHELL_ASYNC *async
    );

//
// -----------------------------------------------------------------------------
// WSManCloseShell API
// -----------------------------------------------------------------------------
//

//
// -----------------------------------------------------------------------------
// Closes a shell; the WSManCloseShell callback is called with
//  WSMAN_FLAG_CALLBACK_END_OF_OPERATION flag as result of this operation
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT void WSMANAPI WSManCloseShell(
    WSMAN_SHELL_HANDLE shellHandle,
    uint32_t flags,
    WSMAN_SHELL_ASYNC *async
    );


//
// -----------------------------------------------------------------------------
// WSManCreateShellEx API - wxf:Create with specific shell Id.
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT void WSMANAPI WSManCreateShellEx(
    WSMAN_SESSION_HANDLE session,
    uint32_t flags,
    const WCHAR* resourceUri,           // shell resource URI
    const WCHAR* shellId,
    WSMAN_SHELL_STARTUP_INFO *startupInfo,
    WSMAN_OPTION_SET *options,
    WSMAN_DATA *createXml,                     // open content for create shell
    WSMAN_SHELL_ASYNC *async,
    WSMAN_SHELL_HANDLE *shell // should be closed using WSManCloseShell
);

//
// -----------------------------------------------------------------------------
// WSManRunShellCommandEx API - rsp:Command with specific command Id.
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT void WSMANAPI WSManRunShellCommandEx(
    WSMAN_SHELL_HANDLE shell,
    uint32_t flags,
    const WCHAR* commandId,
    const WCHAR* commandLine,
    WSMAN_COMMAND_ARG_SET *args,
    WSMAN_OPTION_SET *options,
    WSMAN_SHELL_ASYNC *async,
    WSMAN_COMMAND_HANDLE *command // should be closed using WSManCloseCommand
);

//
// -----------------------------------------------------------------------------
// WSManDisconnectShell API - rsp:Disconnect
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT void WSMANAPI WSManDisconnectShell(
    WSMAN_SHELL_HANDLE shell,
    uint32_t flags,
    WSMAN_SHELL_DISCONNECT_INFO* disconnectInfo,
    WSMAN_SHELL_ASYNC *async
    );

//
// -----------------------------------------------------------------------------
// WSManReconnectShell API - rsp:Disconnect
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT void WSMANAPI WSManReconnectShell(
    WSMAN_SHELL_HANDLE shell,
    uint32_t flags,
    WSMAN_SHELL_ASYNC *async
    );

//
// -----------------------------------------------------------------------------
// WSManReconnectShell API - rsp:Disconnect
// This is a temporary API for first week's delivery. This will be replaced
// by an API that does not take a callback. Instead the callback supplied to
// WSManRunShellCommand is used to report the completion of this operation
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT void WSMANAPI WSManReconnectShellCommand(
    WSMAN_COMMAND_HANDLE commandHandle,
    uint32_t flags,
    WSMAN_SHELL_ASYNC *async
    );

//
// -----------------------------------------------------------------------------
// WSManConnectShell API - rsp:Connect
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT void WSMANAPI WSManConnectShell(
    WSMAN_SESSION_HANDLE session,
    uint32_t flags,
    const WCHAR* resourceUri,
    const WCHAR* shellId,           // shell Identifier
    WSMAN_OPTION_SET *options,
    WSMAN_DATA *connectXml,                     // open content for connect shell
    WSMAN_SHELL_ASYNC *async,
    WSMAN_SHELL_HANDLE *shell // should be closed using WSManCloseShell
);

//
// -----------------------------------------------------------------------------
// WSManConnectShellCommand API - rsp:Connect
// -----------------------------------------------------------------------------
//
WSMAN_EXPORT void WSMANAPI WSManConnectShellCommand(
    WSMAN_SHELL_HANDLE shell,
    uint32_t flags,
    const WCHAR* commandId,  //command Identifier
    WSMAN_OPTION_SET *options,
    WSMAN_DATA *connectXml,                // open content for connect command
    WSMAN_SHELL_ASYNC *async,
    WSMAN_COMMAND_HANDLE *command // should be closed using WSManCloseCommand
);










typedef struct _WSMAN_CERTIFICATE_DETAILS
{
    const WCHAR * subject;         // Certificate subject in distinguished form
                            // Ex: "CN=xyz.com, OU=xyz management, O=Microsoft, L=Redmond, S=Washington, C=US"
    const WCHAR * issuerName;      // Certificate issuer in distinguished form
                            // Ex: "CN=Microsoft Secure Server Authority, DC=redmond, DC=corp, DC=microsoft, DC=com"
    const WCHAR * issuerThumbprint;// Thumbprint of Certificate issuer
    const WCHAR * subjectName;     // Certificate Subject Alternative Name (SAN) if available or subject Common Name (CN)
                            // Ex: "xyz.com"
} WSMAN_CERTIFICATE_DETAILS;

typedef struct _WSMAN_SENDER_DETAILS
{
    const WCHAR * senderName;                  // Username of the sender
    const WCHAR * authenticationMechanism;      //
    WSMAN_CERTIFICATE_DETAILS *certificateDetails; // valid only if the authentication is client certificates
    HANDLE clientToken;
    const WCHAR * httpURL;
} WSMAN_SENDER_DETAILS;

typedef struct _WSMAN_PLUGIN_REQUEST
{
    WSMAN_SENDER_DETAILS *senderDetails;
    const WCHAR * locale;
    const WCHAR * resourceUri;
    WSMAN_OPERATION_INFO *operationInfo;
    volatile BOOL shutdownNotification;
    HANDLE shutdownNotificationHandle;
    const WCHAR * dataLocale;
} WSMAN_PLUGIN_REQUEST;



/* ===================================================================
 *  * Following APIs are callbacks from the _PLUGIN_
 * APIs back into the infrastructure to report
 * results and contexts, or to query extra
 * information about the shell
 * ===================================================================
 */
uint32_t WSMANAPI WSManPluginReportContext(
    WSMAN_PLUGIN_REQUEST *requestDetails,
    uint32_t flags,
    void * context
    );

#define WSMAN_FLAG_RECEIVE_RESULT_NO_MORE_DATA 1
#define WSMAN_FLAG_RECEIVE_FLUSH               2
#define WSMAN_FLAG_RECEIVE_RESULT_DATA_BOUNDARY 4

uint32_t WSMANAPI WSManPluginReceiveResult(
    WSMAN_PLUGIN_REQUEST *requestDetails,
    uint32_t flags,
    const WCHAR * stream,
    WSMAN_DATA *streamResult,
    const WCHAR * commandState,
    uint32_t exitCode
    );

uint32_t WSMANAPI WSManPluginOperationComplete(
    WSMAN_PLUGIN_REQUEST *requestDetails,
    uint32_t flags,
    uint32_t errorCode,
    const WCHAR * extendedInformation
    );

#define WSMAN_PLUGIN_PARAMS_MAX_ENVELOPE_SIZE 1
#define WSMAN_PLUGIN_PARAMS_TIMEOUT 2
#define WSMAN_PLUGIN_PARAMS_REMAINING_RESULT_SIZE 3
#define WSMAN_PLUGIN_PARAMS_LARGEST_RESULT_SIZE 4
#define WSMAN_PLUGIN_PARAMS_GET_REQUESTED_LOCALE 5 /* Returns WSMAN_DATA_TEXT */
#define WSMAN_PLUGIN_PARAMS_GET_REQUESTED_DATA_LOCALE 6 /* Returns WSMAN_DATA_TEXT */


uint32_t WSMANAPI WSManPluginGetOperationParameters (
    WSMAN_PLUGIN_REQUEST *requestDetails,
    uint32_t flags,
    WSMAN_DATA *data
    );

uint32_t WSMANAPI WSManPluginGetConfiguration (
    void * pluginContext,
    uint32_t flags,
    WSMAN_DATA *data
);

uint32_t WSMANAPI WSManPluginReportCompletion(
    void * pluginContext,
    uint32_t flags
);

uint32_t WSMANAPI WSManPluginFreeRequestDetails(WSMAN_PLUGIN_REQUEST *requestDetails);

#define WSMAN_PLUGIN_STARTUP_REQUEST_RECEIVED     0x0
#define WSMAN_PLUGIN_STARTUP_AUTORESTARTED_REBOOT 0x1
#define WSMAN_PLUGIN_STARTUP_AUTORESTARTED_CRASH  0x2

#define WSMAN_PLUGIN_SHUTDOWN_SYSTEM  1
#define WSMAN_PLUGIN_SHUTDOWN_SERVICE 2
#define WSMAN_PLUGIN_SHUTDOWN_IISHOST 3
#define WSMAN_PLUGIN_SHUTDOWN_IDLETIMEOUT_ELAPSED 4


/* ===================================================================
 * Following functions are plug-in APIs that the shell infrastructure
 * calls into
 * ===================================================================
 */

#define WSMAN_FLAG_SEND_NO_MORE_DATA 1


/* Default signal codes where _EXIT comes from the client to confirm the command has completed and is the last request targeting the command */
#define WSMAN_SIGNAL_CODE_TERMINATE WSMAN_SHELL_NS PAL_T("/signal/Terminate")
#define WSMAN_SIGNAL_CODE_BREAK     WSMAN_SHELL_NS PAL_T("/signal/Break")
#define WSMAN_SIGNAL_CODE_PAUSE     WSMAN_SHELL_NS PAL_T("/signal/Pause")
#define WSMAN_SIGNAL_CODE_RESUME    WSMAN_SHELL_NS PAL_T("/signal/Resume")
#define WSMAN_SIGNAL_CODE_EXIT      WSMAN_SHELL_NS PAL_T("/signal/Exit")


void WSMANAPI WSManPluginReleaseShellContext(
    void * shellContext
    );

void WSMANAPI WSManPluginReleaseCommandContext(
    void * shellContext,
    void * commandContext
    );

typedef void (WSMANAPI *WSManPluginShutdownCallback)(void *shutdownContext);

void WSMANAPI WSManPluginRegisterShutdownCallback(
    WSMAN_PLUGIN_REQUEST *requestDetails,
    WSManPluginShutdownCallback shutdownCallback,
    void *shutdownContext);

typedef void (WSMANAPI *ShutdownPluginFuncPtr)(void* pluginContext);

typedef void (WSMANAPI *WSManPluginShellFuncPtr)(
    void* pluginContext,
    WSMAN_PLUGIN_REQUEST *requestDetails,
    uint32_t flags,
    WCHAR *extraInfo,
    WSMAN_SHELL_STARTUP_INFO *startupInfo,
    WSMAN_DATA *inboundShellInformation
    );

typedef void (WSMANAPI *WSManPluginConnectFuncPtr)(
    void* pluginContext,
    WSMAN_PLUGIN_REQUEST *requestDetails,
    uint32_t flags,
    void* shellContext,
    void* commandContext,
    WSMAN_DATA *inboundConnectInformation
    );

typedef void (WSMANAPI *WSManPluginReleaseShellContextFuncPtr)(
    void* pluginContext,
    void* shellContext
    );

typedef void (WSMANAPI *WSManPluginCommandFuncPtr)(
    void* pluginContext,
    WSMAN_PLUGIN_REQUEST *requestDetails,
    uint32_t flags,
    void* shellContext,
    WCHAR *commandLine,
    WSMAN_COMMAND_ARG_SET *arguments
    );

typedef void (WSMANAPI *WSManPluginReleaseCommandContextFuncPtr)(
    void* pluginContext,
    void* shellContext,
    void* commandContext
    );

typedef void (WSMANAPI *WSManPluginSendFuncPtr)(
    void* pluginContext,
    WSMAN_PLUGIN_REQUEST *requestDetails,
    uint32_t flags,
    void* shellContext,
    void* commandContext,
    WCHAR *stream,
    WSMAN_DATA *inboundData
    );

typedef void (WSMANAPI *WSManPluginReceiveFuncPtr)(
    void* pluginContext,
    WSMAN_PLUGIN_REQUEST *requestDetails,
    uint32_t flags,
    void* shellContext,
    void* commandContext,
    WSMAN_STREAM_ID_SET* streamSet
    );

typedef void (WSMANAPI *WSManPluginSignalFuncPtr)(
    void* pluginContext,
    WSMAN_PLUGIN_REQUEST *requestDetails,
    uint32_t flags,
    void* shellContext,
    void* commandContext,
    WCHAR *code);

typedef void (WSMANAPI *WSManPluginShellCloseFuncPtr)(
   void* pluginContext,
   void* shellContext);

/* List of managed powershell functions we call into to carry out shell operations */
typedef struct _PwrshPluginWkr_Ptrs
{
    ShutdownPluginFuncPtr shutdownPluginFuncPtr;
    WSManPluginShellFuncPtr wsManPluginShellFuncPtr;
    WSManPluginReleaseShellContextFuncPtr wsManPluginReleaseShellContextFuncPtr;
    WSManPluginCommandFuncPtr wsManPluginCommandFuncPtr;
    WSManPluginReleaseCommandContextFuncPtr wsManPluginReleaseCommandContextFuncPtr;
    WSManPluginSendFuncPtr wsManPluginSendFuncPtr;
    WSManPluginReceiveFuncPtr wsManPluginReceiveFuncPtr;
    WSManPluginSignalFuncPtr wsManPluginSignalFuncPtr;
    WSManPluginConnectFuncPtr wsManPluginConnectFuncPtr;
    WSManPluginShellCloseFuncPtr wsManPluginShellCloseFuncPtr;
} PwrshPluginWkr_Ptrs;

/* Function that calls into powershell to get the full set of function pointers */
typedef uint32_t (WSMANAPI *InitPluginWkrPtrsFuncPtr)(PwrshPluginWkr_Ptrs* wkrPtrs);

// Jetify WSMan APIs

bool WSManDll_Init();
void WSManDll_Uninit();

#endif /* JETIFY_WSMAN_H */
